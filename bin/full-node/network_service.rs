// Copyright (C) 2019-2020 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Background network service.
//!
//! The [`NetworkService`] manages background tasks dedicated to connecting to other nodes.
//! Importantly, its design is oriented towards the particular use case of the full node.
//!
//! The [`NetworkService`] spawns one background task (using the [`Config::tasks_executor`]) for
//! each active TCP socket, plus one for each TCP listening socket. Messages are exchanged between
//! the service and these background tasks.

// TODO: doc
// TODO: re-review this once finished

use ahash::RandomState;
use core::{iter, pin::Pin, time::Duration};
use futures::{
    channel::{mpsc, oneshot},
    lock::Mutex,
    prelude::*,
};
use hashbrown::HashMap;
use std::{io, sync::Arc, time::Instant};
use substrate_lite::network::{
    libp2p::{connection, multiaddr::Multiaddr, peer_id::PeerId},
    request_response, with_buffers,
};

/// Configuration for a [`NetworkService`].
pub struct Config {
    /// Closure that spawns background tasks.
    pub tasks_executor: Box<dyn FnMut(Pin<Box<dyn Future<Output = ()> + Send>>) + Send>,

    /// Addresses to listen for incoming connections.
    pub listen_addresses: Vec<Multiaddr>,

    /// Key used for the encryption layer.
    /// This is a Noise static key, according to the Noise specifications.
    /// Signed using the actual libp2p key.
    pub noise_key: connection::NoiseKey,
}

/// Event generated by [`NetworkService::next_event`].
#[derive(Debug)]
pub enum Event {
    Connected(PeerId),
}

pub struct NetworkService {
    /// Fields behind a mutex.
    guarded: Mutex<Guarded>,

    /// See [`Config::noise_key`].
    noise_key: Arc<connection::NoiseKey>,

    /// Receiver of events sent by background tasks.
    ///
    /// > **Note**: This field is not in [`Guarded`] despite being inside of a mutex. The mutex
    /// >           around this receiver is kept locked while an event is being waited for, and it
    /// >           would be undesirable to block access to the other fields of [`Guarded`] during
    /// >           that time.
    from_background: Mutex<mpsc::Receiver<FromBackground>>,

    /// Sending side of [`NetworkService::from_background`]. Clones of this field are created when
    /// a background task is spawned.
    to_foreground: mpsc::Sender<FromBackground>,
}

/// Fields of [`NetworkService`] behind a mutex.
struct Guarded {
    /// See [`Config::tasks_executor`].
    tasks_executor: Box<dyn FnMut(Pin<Box<dyn Future<Output = ()> + Send>>) + Send>,

    connections: slab::Slab<mpsc::Sender<ToConnection>>,

    peers: HashMap<PeerId, Vec<usize>, RandomState>,
}

impl NetworkService {
    /// Initializes the network service with the given configuration.
    pub async fn new(mut config: Config) -> Result<Arc<Self>, io::Error> {
        let noise_key = Arc::new(config.noise_key);

        let (to_foreground, from_background) = mpsc::channel(64); // TODO: size

        // For each listening address in the configuration, create a background task dedicated to
        // listening on that address.
        for listen_address in config.listen_addresses {
            // TODO: proper address
            let tcp_listener = async_std::net::TcpListener::bind("0.0.0.0:30333").await?;
            let mut to_foreground = to_foreground.clone();

            // TODO: don't spawn immediately, or have some sort of barrier, so that we liberate the TCP listeners in case of error.
            (config.tasks_executor)(Box::pin(async move {
                loop {
                    let (socket, _addr) = match tcp_listener.accept().await {
                        Ok(v) => v,
                        Err(_) => {
                            // Errors here can happen if the accept failed, for example if no file
                            // descriptor is available.
                            // A wait is added in order to avoid having a busy-loop failing to
                            // accept connections.
                            futures_timer::Delay::new(Duration::from_secs(2)).await;
                            continue;
                        }
                    };

                    if to_foreground
                        .send(FromBackground::IncomingConnection(socket))
                        .await
                        .is_err()
                    {
                        break;
                    }
                }
            }))
        }

        /*let mut peerset = substrate_lite::network::peerset::Peerset::new(substrate_lite::network::peerset::Config {
            randomness_seed: [0; 32],
        });*/

        // peerset.insert("/dns/p2p.cc1-0.polkadot.network/tcp/30100/p2p/12D3KooWEdsXX9657ppNqqrRuaCHFvuNemasgU5msLDwSJ6WqsKc");
        // peerset.insert("/dns/p2p.cc1-1.polkadot.network/tcp/30100/p2p/12D3KooWAtx477KzC8LwqLjWWUG6WF4Gqp2eNXmeqAG98ehAMWYH");
        // peerset.insert("/dns/p2p.cc1-2.polkadot.network/tcp/30100/p2p/12D3KooWAGCCPZbr9UWGXPtBosTZo91Hb5M3hU8v6xbKgnC5LVao");
        // peerset.insert("/dns/p2p.cc1-3.polkadot.network/tcp/30100/p2p/12D3KooWJ4eyPowiVcPU46pXuE2cDsiAmuBKXnFcFPapm4xKFdMJ");
        // peerset.insert("/dns/p2p.cc1-4.polkadot.network/tcp/30100/p2p/12D3KooWNMUcqwSj38oEq1zHeGnWKmMvrCFnpMftw7JzjAtRj2rU");
        // peerset.insert("/dns/p2p.cc1-5.polkadot.network/tcp/30100/p2p/12D3KooWDs6LnpmWDWgZyGtcLVr3E75CoBxzg1YZUPL5Bb1zz6fM");
        // peerset.insert("/dns/cc1-0.parity.tech/tcp/30333/p2p/12D3KooWSz8r2WyCdsfWHgPyvD8GKQdJ1UAiRmrcrs8sQB3fe2KU");
        // peerset.insert("/dns/cc1-1.parity.tech/tcp/30333/p2p/12D3KooWFN2mhgpkJsDBuNuE5427AcDrsib8EoqGMZmkxWwx3Md4");

        /*while num_outgoing_connected_pending < 25 {
            if let Some(node) = peerset.overlay(0).unwrap().random_disconnected() {
                for address in node.addresses() {

                }

                node.connect();
            }
        }*/

        // TODO: temporary, for testing
        let mut connections = slab::Slab::new();
        {
            let tcp_socket = async_std::net::TcpStream::connect("p2p.cc1-4.polkadot.network:30100")
                .await
                .unwrap();
            let (tx, rx) = mpsc::channel(8);
            let connection_id = connections.insert(tx);
            (config.tasks_executor)(Box::pin(connection_task(
                tcp_socket,
                true,
                noise_key.clone(),
                connection_id,
                to_foreground.clone(),
                rx,
            )));
        }

        Ok(Arc::new(NetworkService {
            guarded: Mutex::new(Guarded {
                tasks_executor: config.tasks_executor,
                connections,
                peers: HashMap::with_hasher(RandomState::with_seeds(
                    rand::random(),
                    rand::random(),
                )),
            }),
            noise_key,
            from_background: Mutex::new(from_background),
            to_foreground,
        }))
    }

    /// Sends a blocks request to the given peer.
    // TODO: more docs
    // TODO: proper error type
    pub async fn blocks_request(
        self: &Arc<Self>,
        target: PeerId,
        config: request_response::BlocksRequestConfig,
    ) -> Result<Vec<request_response::BlockData>, ()> {
        let mut guarded = self.guarded.lock().await;

        // TODO: don't unwrap and all
        let connection = *guarded.peers.get(&target).unwrap().first().unwrap();

        let (send_back, receive_result) = oneshot::channel();

        // TODO: is awaiting here a good idea? if the background task is stuck, we block the entire `Guarded`
        guarded
            .connections
            .get_mut(connection)
            .unwrap()
            .send(ToConnection::BlocksRequest { config, send_back })
            .await
            .unwrap();

        // Everything must be unlocked at this point.
        drop(guarded);

        // Wait for the result of the request. Can take a long time (i.e. several seconds).
        match receive_result.await {
            Ok(r) => r,
            Err(_) => Err(()),
        }
    }

    /// Returns the next event that happens in the network service.
    ///
    /// If this method is called multiple times simultaneously, the events will be distributed
    /// amongst the different calls in an unpredictable way.
    pub async fn next_event(&self) -> Event {
        loop {
            match self.from_background.lock().await.next().await.unwrap() {
                FromBackground::IncomingConnection(tcp_socket) => {
                    // A new socket has been accepted by a listener.
                    // Add the socket to the local state, and spawn the task of that connection.
                    let (tx, rx) = mpsc::channel(8);
                    let mut guarded = self.guarded.lock().await;
                    let connection_id = guarded.connections.insert(tx);
                    (guarded.tasks_executor)(Box::pin(connection_task(
                        tcp_socket,
                        false,
                        self.noise_key.clone(),
                        connection_id,
                        self.to_foreground.clone(),
                        rx,
                    )));
                }
                FromBackground::HandshakeError { connection_id, .. } => {
                    let mut guarded = self.guarded.lock().await;
                    guarded.connections.remove(connection_id);
                }
                FromBackground::HandshakeSuccess {
                    connection_id,
                    peer_id,
                } => {
                    let mut guarded = self.guarded.lock().await;
                    guarded
                        .peers
                        .entry(peer_id.clone())
                        .or_default()
                        .push(connection_id);
                    return Event::Connected(peer_id);
                }
                FromBackground::Disconnected { connection_id } => {
                    let mut guarded = self.guarded.lock().await;
                    guarded.connections.remove(connection_id);
                    // TODO: remove from peers as well
                }
            }
        }
    }
}

/// Message sent to a background task dedicated to a connection.
enum ToConnection {
    /// Start a block request. See [`NetworkService::blocks_request`].
    BlocksRequest {
        config: request_response::BlocksRequestConfig,
        send_back: oneshot::Sender<Result<Vec<request_response::BlockData>, ()>>,
    },
}

/// Messsage sent from a background task and dedicated to the main [`NetworkService`]. Processed
/// in [`NetworkService::next_event`].
enum FromBackground {
    /// A new socket has arrived on a listening endpoint.
    IncomingConnection(async_std::net::TcpStream),

    HandshakeError {
        connection_id: usize,
        error: HandshakeError,
    },
    HandshakeSuccess {
        connection_id: usize,
        peer_id: PeerId,
    },

    /// Connection has closed.
    ///
    /// This only concerns connections onto which the handshake had succeeded. For connections on
    /// which the handshake hadn't succeeded, a [`FromBackground::HandshakeError`] is emitted
    /// instead.
    Disconnected {
        connection_id: usize,
    },
}

/// Asynchronous task managing a specific TCP connection.
async fn connection_task(
    tcp_socket: async_std::net::TcpStream,
    is_initiator: bool,
    noise_key: Arc<connection::NoiseKey>,
    connection_id: usize,
    mut to_foreground: mpsc::Sender<FromBackground>,
    mut to_connection: mpsc::Receiver<ToConnection>,
) {
    // The socket is wrapped around a `WithBuffers` object containing a read buffer and a write
    // buffer. These are the buffers whose pointer is passed to `read(2)` and `write(2)` when
    // reading/writing the socket.
    let tcp_socket = with_buffers::WithBuffers::new(tcp_socket);
    futures::pin_mut!(tcp_socket);

    // Connections start with a handshake where the encryption and multiplexing protocols are
    // negotiated.
    let (connection_prototype, peer_id) =
        match perform_handshake(&mut tcp_socket, &noise_key, is_initiator).await {
            Ok(v) => v,
            Err(error) => {
                let _ = to_foreground.send(FromBackground::HandshakeError {
                    connection_id,
                    error,
                });
                return;
            }
        };

    // Configure the `connection_prototype` to turn it into an actual connection.
    let mut connection = connection_prototype.into_connection::<_, oneshot::Sender<_>, (), _, _>(
        connection::established::Config {
            in_request_protocols: iter::once("/ipfs/ping/1.0.0"),
            in_notifications_protocols: iter::once("/dot/block-announces/1"), // TODO:
            randomness_seed: rand::random(),
        },
    );

    // Notify the outside of the transition from handshake to actual connection.
    if to_foreground
        .send(FromBackground::HandshakeSuccess {
            connection_id,
            peer_id,
        })
        .await
        .is_err()
    {
        return;
    }

    // Set to a timer after which the state machine of the connection needs an update.
    let mut poll_after: futures_timer::Delay;

    loop {
        let (read_buffer, write_buffer) = match tcp_socket.buffers() {
            Ok(b) => b,
            Err(_) => {
                let _ = to_foreground.send(FromBackground::Disconnected { connection_id });
                return;
            }
        };

        let now = Instant::now();

        let read_write =
            match connection.read_write(now, read_buffer.map(|b| b.0), write_buffer.unwrap().0) {
                Ok(rw) => rw,
                Err(_) => {
                    let _ = to_foreground.send(FromBackground::Disconnected { connection_id });
                    return;
                }
            };
        connection = read_write.connection;

        if let Some(wake_up) = read_write.wake_up_after {
            if wake_up > now {
                let dur = wake_up - now;
                poll_after = futures_timer::Delay::new(dur);
            } else {
                poll_after = futures_timer::Delay::new(Duration::from_secs(0));
            }
        } else {
            poll_after = futures_timer::Delay::new(Duration::from_secs(3600));
        }

        tcp_socket.advance(read_write.read_bytes, read_write.written_bytes);

        match read_write.event {
            Some(connection::established::Event::Response {
                response,
                user_data,
                ..
            }) => {
                if let Ok(response) = response {
                    let decoded = request_response::decode_block_response(&response).unwrap();
                    let _ = user_data.send(Ok(decoded));
                } else {
                    let _ = user_data.send(Err(()));
                }
            }
            _ => {}
        }

        if read_write.read_bytes != 0 || read_write.written_bytes != 0 {
            continue;
        }

        loop {
            futures::select! {
                _ = tcp_socket.as_mut().process().fuse() => break,
                timeout = (&mut poll_after).fuse() => { // TODO: no, ref mut + fuse() = probably panic
                    // Nothing to do, but guarantees that we loop again.
                    break;
                },
                message = to_connection.select_next_some().fuse() => {
                    match message {
                        ToConnection::BlocksRequest { config, send_back } => {
                            let start = config.start.clone();
                            let request = request_response::build_block_request(config)
                                .fold(Vec::new(), |mut a, b| {
                                    a.extend_from_slice(b.as_ref());
                                    a
                                });
                            let id = connection.add_request(Instant::now(), "/dot/sync/2", request, send_back);
                            println!("start request on {:?} for blocks starting at {:?}", id, start);
                        }
                    }
                }
            }
        }
    }
}

/// Drives the handshake of the given connection.
///
/// # Panic
///
/// Panics if the `tcp_socket` is closed in the writing direction.
///
async fn perform_handshake(
    tcp_socket: &mut Pin<&mut with_buffers::WithBuffers<async_std::net::TcpStream>>,
    noise_key: &connection::NoiseKey,
    is_initiator: bool,
) -> Result<(connection::established::ConnectionPrototype, PeerId), HandshakeError> {
    let mut handshake = connection::handshake::Handshake::new(is_initiator);

    let timeout = futures_timer::Delay::new(Duration::from_secs(20)); // TODO: proper value
    futures::pin_mut!(timeout);

    loop {
        match handshake {
            connection::handshake::Handshake::Success {
                remote_peer_id,
                connection,
            } => {
                break Ok((connection, remote_peer_id));
            }
            connection::handshake::Handshake::NoiseKeyRequired(key) => {
                handshake = key.resume(noise_key).into()
            }
            connection::handshake::Handshake::Healthy(healthy) => {
                let (read_buffer, write_buffer) = match tcp_socket.buffers() {
                    Ok(v) => v,
                    Err(_) => return Err(HandshakeError::Io),
                };

                // Update the handshake state machine with the received data, and writes in the
                // write buffer..
                let (new_state, num_read, num_written) = {
                    let read_buffer = read_buffer.ok_or(HandshakeError::UnexpectedEof)?.0;
                    // `write_buffer` can only be `None` if `close` has been manually called,
                    // which never happens.
                    let write_buffer = write_buffer.unwrap().0;
                    healthy.read_write(read_buffer, write_buffer)?
                };
                handshake = new_state;
                tcp_socket.advance(num_read, num_written);

                if num_read != 0 || num_written != 0 {
                    continue;
                }

                // Wait either for something to happen on the socket, or for the timeout to
                // trigger.
                {
                    let process_future = tcp_socket.as_mut().process();
                    futures::pin_mut!(process_future);
                    match future::select(process_future, &mut timeout).await {
                        future::Either::Left(_) => {}
                        future::Either::Right(_) => return Err(HandshakeError::Timeout),
                    }
                }
            }
        }
    }
}

#[derive(Debug, derive_more::Display, derive_more::From)]
enum HandshakeError {
    Io,
    Timeout,
    UnexpectedEof,
    Protocol(connection::handshake::HandshakeError),
}
